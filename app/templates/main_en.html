{% extends "index.html" %}
{% block content %}
<div id="loading"><div id="overlay"></div><div id='overlay_text'><h1>Loading ... </h1></div></div>

<div id="content">

<div id="LeftPanel" align=left style="width: 45%; height: 100%; float: left; padding-right: 5%; background: rgba(170,170,170,0.2);">
  <div id="LeftPanel" align=left style="width: 95%; height: 100%; float: left; padding-left: 5%; background: rgba(170,170,170,0.0);">
    <div align='left'>
      <h3>Local Sea Level Projections</h3>
      The presented local sea level estimations are provided by Robert Kopp et al. (2014). Factors included in sea level estimations are:
      <ul>
        <li> Ice sheet components (Greenland, West Antarctica, East Antarctica)</li>
        <li> Glacier and ice caps</li>
        <li> Surface mass balance</li>
        <li> Global mean thermal expansion</li>
        <li> Regional oceanographic processes </li>
        <li> Land water storage</li>
        <li> Long-term non climatic sea-level changes </li>
      </ul>
    </div>
    <br>
    <div class="ui-widget">
      <form method="POST" action="/location_typed">
        <label for="tags">Location: </label>
        <input id="tags" name='station' value="{{name}}">
     </form>
    </div>

    <div id="map" style="width: 400px; height: 300px;" class="smallmap"></div>
      <div class="container-fluid">
         <div class="row-fluid">
          <div class="col-lg-12 col-md-12 col-sm-12">
            <div id="map" class="map"></div>
            	<div id="popup" class="popup">
            		<a href="/" id="popup-closer"> </a>
            		<div id="popup-content"></div>
            	</div>
            </div>
         </div>
      </div>
    <script>

      var current_name = "{{name}}";

      var iconFeatures =[];
      var station_names = {{station_names|safe}};
      var station_lons = {{station_lons|safe}};
      var station_lats = {{station_lats|safe}};
      var nstations = {{nstations}};

      // all stations
      for (i = 0; i<nstations; i++){
        var iconFeature = new ol.Feature({
          geometry: new ol.geom.Point(ol.proj.fromLonLat([station_lons[i],station_lats[i]], 'EPSG:4326')),
          name: station_names[i],
        });
        if (station_names[i]==current_name){
          var iconStyle = new ol.style.Style({
            image: new ol.style.Icon(/** @type {olx.style.IconOptions} */ ({
              anchor: [0.5, 1],
              anchorXUnits: 'fraction',
              anchorYUnits: 'fraction',
              src: 'http://dev.openlayers.org/img/marker-gold.png'
            }))
          });
        } else {
          var iconStyle = new ol.style.Style({
            image: new ol.style.Icon(/** @type {olx.style.IconOptions} */ ({
              anchor: [0.5, 1],
              anchorXUnits: 'fraction',
              anchorYUnits: 'fraction',
              src: 'http://dev.openlayers.org/img/marker-green.png'
            }))
          });
        };
        iconFeature.setStyle(iconStyle);
        iconFeatures.push(iconFeature);
      }

      $( function() {
        var availableTags = station_names;
        $( "#tags" ).autocomplete({
          source: availableTags
        });
      } );

      // all grids
      var grid_names = {{grid_names|safe}};
      var grid_xmin = {{grid_xmin|safe}};
      var grid_xmax = {{grid_xmax|safe}};
      var grid_ymin = {{grid_ymin|safe}};
      var grid_ymax = {{grid_ymax|safe}};
      var ngrid = {{ngrid}};


      for (i = 0; i<ngrid; i++){
        if (grid_names[i]==current_name){
          var iconFeature = new ol.Feature({
            geometry: new ol.geom.Polygon.fromExtent(ol.proj.fromLonLat([grid_xmin[i],grid_ymin[i],grid_xmax[i],grid_ymax[i]], 'EPSG:4326'))  ,
            name:grid_names[i]
          });
          var iconStyle = new ol.style.Style({
            fill: new ol.style.Fill({
              color: [150, 0,0,0.5],
            }),
            stroke: new ol.style.Stroke({
              color: [150, 150,0,1],
              width: 2
            })
          });
          iconFeature.setStyle(iconStyle);
          iconFeatures.push(iconFeature);
        };
        if (grid_names[i]!=current_name){
          var iconFeature = new ol.Feature({
            geometry: new ol.geom.Polygon.fromExtent(ol.proj.fromLonLat([grid_xmin[i],grid_ymin[i],grid_xmax[i],grid_ymax[i]], 'EPSG:4326'))  ,
            name:grid_names[i]
          });
          var iconStyle = new ol.style.Style({
            fill: new ol.style.Fill({
              color: [150, 150,0,0.3],
            }),
            stroke: new ol.style.Stroke({
              color: [150, 150,0,1],
              width: 2
            })
          });
          iconFeature.setStyle(iconStyle);
          iconFeatures.push(iconFeature);
        };
      }


      var vectorSource = new ol.source.Vector({
        features: iconFeatures
      });

      var vectorLayer = new ol.layer.Vector({
        source: vectorSource,
      });

      var rasterLayer = new ol.layer.Tile({
        source: new ol.source.TileJSON({
          url: 'https://api.tiles.mapbox.com/v3/mapbox.natural-earth-hypso-bathy.json?secure',
          crossOrigin: ''
        })
      });

      var center_lon = {{center_lon}};
      var center_lat = {{center_lat}};
      var zoom = {{zoom}};
      var map = new ol.Map({
        layers: [rasterLayer, vectorLayer],
        target: document.getElementById('map'),
        view: new ol.View({
          center: ol.proj.fromLonLat([center_lon, center_lat], 'EPSG:4326'),
          zoom: zoom,
          projection: 'EPSG:4326'
        })
      });

      function elem_id(id) {
      	return document.getElementById(id);
      }

      var popup = elem_id('popup');
      var popup_closer = elem_id('popup-closer');
      var popup_content = elem_id('popup-content');
      var olpopup = new ol.Overlay({
          element: popup,
          autoPan: false
      });
      map.addOverlay(olpopup);
      popup_closer.onclick = function () {
          olpopup.setPosition(undefined);
          return false;
      };
      var OpenPopup = function (evt) {
          var feature = map.forEachFeatureAtPixel(evt.pixel,
          function (feature, layer) {
              if (feature) {
                if (feature.get('name').substr(0, 4) != 'grid'){
                  var coord = map.getCoordinateFromPixel(evt.pixel);
                  if (typeof feature.get('features') === 'undefined') {
                      popup_content.innerHTML =feature.get('name');
                  } else {
                      var cfeatures = feature.get('features');
                      if (cfeatures.length > 1) {
                          popup_content.innerHTML = '<h5><strong>all "Sub-Features"</strong></h5>';
                          for (var i = 0; i < cfeatures.length; i++) {
                              $(popup_content).append(cfeatures[i].get('name'));
                          }
                      }
                      if (cfeatures.length == 1) {
                          popup_content.innerHTML = cfeatures[0].get('name');
                      }
                  }
                  olpopup.setPosition(coord);
                };
              } else {
                  olpopup.setPosition(undefined);
              }
          });
          var pixel = map.getEventPixel(evt.originalEvent);
          var hit = map.hasFeatureAtPixel(pixel);
          map.getTarget().style.cursor = hit ? 'pointer' : '';
      };
      map.on('pointermove', OpenPopup);

      map.on('click', function(evt) {
        var feature = map.forEachFeatureAtPixel(evt.pixel,
            function(feature) {
              return feature;
            });
        if (feature) {
          var coordinates = feature.getGeometry().getCoordinates();
          window.location = "/location/"+feature.get('name');
        }

      });

    </script>
    <br>
    We strongly recommend using projections for <b>tide gauged stations</b> (marked as <IMG SRC='/static/marker-green.png' ALT=' ' WIDTH=3%></IMG>). Gridded sea level projections are available globally (yellow squares), but theses projections are less reliable.
    <br>
    <h3>References</h3>
    <p style="font-size:80%;">Kopp R E, Horton R M, Little C M, Mitrovica J X, Oppenheimer M, Rasmussen D J, Strauss B H and Tebaldi C 2014 Earth’s Future Probabilistic 21st and 22nd century sea-level projections at a global network of tide-gauge sites Earth’s Future</p>
  </div>
</div>

<div id="LeftPanel" align='left' style="width: 5%; height: 100%; float: left; padding-left=0%">
  <br>
</div>

<div id="LeftPanel" align='left' style="width: 45%; height: 100%; float: left; padding-left=5%">

  {% if name.split('_')[0]=='grid' %}
  <p style="background-color:rgba(250,170,170,0.5);"><b>We strongly recommend using projections for tide gauged stations if possible!</b></p>
  {% endif %}
  <p>Local sea level projections for {{name}} for a low emission scenario (RCP26 in blue), an intermediate emission scenario (RCP45 in green) and a high emission scenario (RCP85 in red). The solid lines represent multi-model medians, the shaded areas include 66% of the models.</p>
  <div class="ui-widget" align='center'>
    <form method="POST" action="/location_typed">
      <!-- <label for="tags">Location: </label> -->
      <input id="tags" name='station' value="{{name}}">
   </form>
  </div>
  <form method="POST" action="/prepare_for_download/{{name}}" style="float: right;"><button type="submit" class="label label-primary" style="margin-right: 5px;">pdf</button></form>
  <IMG SRC={{ plot_file }} ALT=' ' WIDTH=90%></IMG>
<!-- </div>
<div id="LeftPanel" align=center style="width: 60%; height: 100%; float: left; padding-left: 5%;"> -->
<br><br>
  <p>Local sea level projections for {{name}} as in the above figure listed for some selected decades. The first column shows the multi-model median projections, columns 2 and 3 show the 66% and 90% model spread, column 4 shows the 99th percentile of the ensemble estimates.</p>
  <table class="table">
    <thead>
      <tr>
        <th colspan="5">{{rcp}}</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>decade</td><td>50</td><td>17-83</td><td>5-95</td><td>99.9</td>
      </tr>
      {% for year in [2030,2050,2100,2150,2200] %}
        <tr>
          <td>{{year}}</td>
          {% for val in ['50','17-83','5-95','99.9'] %}
          <td>
            {% for rcp in ['rcp26','rcp45','rcp85'] %}
            <!-- <font color={{color_dict[rcp]}}>{{table[rcp][year][val]}}</font> -->
              <div style="color:{{color_dict[rcp]}};">{{table[rcp][year][val]}}</div>
            {% endfor %}
          </td>
          {% endfor %}
        </tr>
      {% endfor %}
    </tbody>
</table>
</div>
</div>
{% endblock %}
